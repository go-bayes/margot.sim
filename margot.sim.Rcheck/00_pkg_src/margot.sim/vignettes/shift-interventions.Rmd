---
title: "Using Shift Interventions in margot.sim"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using Shift Interventions in margot.sim}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(margot.sim)
```

## Introduction

This vignette demonstrates how to implement shift interventions in `margot.sim`, similar to those used in the `lmtp` package for modified treatment policies.

## Basic Shift Interventions

### Example 1: LMTP-Style Shifts

Here's how to implement the exact pattern you described:

```{r lmtp-style}
# Define score bounds
min_score <- 1
max_score <- 7

# Create shift functions matching lmtp style
shift_up <- function(data, time, trt) {
  # Keep baseline (t0) as observed
  if (time == 0) {
    return(data[[trt]])
  }
  
  # Apply shift at wave 1
  if (time == 1) {
    values <- data[[trt]]
    return(ifelse(values <= max_score - 1, values + 1, max_score))
  }
  
  # No treatment at later waves
  return(rep(0, nrow(data)))
}

shift_down <- function(data, time, trt) {
  # Keep baseline (t0) as observed  
  if (time == 0) {
    return(data[[trt]])
  }
  
  # Apply shift at wave 1
  if (time == 1) {
    values <- data[[trt]]
    return(ifelse(values >= min_score + 1, values - 1, min_score))
  }
  
  # No treatment at later waves
  return(rep(0, nrow(data)))
}

# Natural (observed) intervention for comparison
natural <- function(data, time, trt) {
  data[[trt]]
}
```

### Example 2: Using in Simulation

```{r simulation-example}
# Simulate data under different shift interventions
results <- margot_simulate_causal(
  n = 1000,
  waves = 3,
  treatments = "a",
  interventions = list(
    natural = natural,
    shift_up = shift_up,
    shift_down = shift_down
  ),
  common_params = list(
    params = list(
      a_lag_y_coef = 0.3,  # True causal effect
      exposure_type = "continuous"
    )
  ),
  seed = 2025
)

# Compare effects
print(results)
```

## Using Helper Functions

The package provides helper functions to create shift interventions:

```{r helper-functions}
# Create bounded shift interventions
shifts <- create_lmtp_style_shifts(
  min_score = 1,
  max_score = 7,
  baseline_wave = 0,  # Keep baseline as observed
  shift_wave = 1      # Apply shift at wave 1
)

# Use in simulation
sim_data <- margot_simulate(
  n = 500,
  waves = 2,
  exposure_type = "continuous",
  intervention = shifts$shift_up,
  seed = 123
)

# Check the intervention worked
cat("Mean exposure at baseline:", mean(sim_data$t0_a), "\n")
cat("Mean exposure at wave 1:", mean(sim_data$t1_a), "\n")
```

## Advanced Shift Patterns

### Threshold-Based Shifts

```{r threshold-shifts}
# Shift everyone below score 3 up to 3
threshold_shift <- create_threshold_shift(
  threshold = 3,
  shift_to = 3,
  direction = "up",
  start_wave = 1
)

# Simulate
sim_threshold <- margot_simulate(
  n = 500,
  waves = 2,
  exposure_type = "continuous",
  intervention = threshold_shift,
  seed = 456
)

# Verify no one below 3 at wave 1
cat("Proportion below 3 at wave 1:", 
    mean(sim_threshold$t1_a < 3, na.rm = TRUE), "\n")
```

### Wave-Specific Shifts

```{r wave-specific}
# Different interventions at different waves
wave_interventions <- create_wave_specific_shift(
  wave_shifts = list(
    "0" = function(x) x,                    # No change at baseline
    "1" = function(x) pmin(x + 1, 7),       # Shift up by 1
    "2" = function(x) pmax(x - 0.5, 1)      # Shift down by 0.5
  )
)

# Simulate
sim_waves <- margot_simulate(
  n = 500,
  waves = 2,
  exposure_type = "continuous",
  intervention = wave_interventions,
  seed = 789
)
```

## Practical Considerations

### 1. Single Point Interventions

For studies with a single intervention point (common in many applications):

```{r single-point}
# Intervention only at wave 1, natural elsewhere
single_point_shift <- function(data, time, trt) {
  if (time == 1) {
    # Apply your shift logic here
    values <- data[[trt]]
    return(pmin(values + 1, max_score))
  } else {
    # Natural values at all other times
    return(data[[trt]])
  }
}
```

### 2. Handling Binary Exposures

For binary exposures, shifts might involve probability changes:

```{r binary-shifts}
# Increase probability of treatment by 20%
prob_shift <- function(data, time, trt) {
  if (time == 0) return(data[[trt]])
  
  # Get current treatment probability
  current_prob <- mean(data[[trt]])
  
  # Increase by 20% (bounded by 1)
  new_prob <- min(current_prob * 1.2, 1)
  
  # Resample with new probability
  rbinom(nrow(data), 1, new_prob)
}
```

### 3. Incorporating Covariates

Shifts can depend on covariates:

```{r covariate-dependent}
# Shift based on confounder value
smart_shift <- function(data, time, trt) {
  if (time == 0) return(data[[trt]])
  
  # Get time-varying confounder
  l_var <- paste0("t", time, "_l")
  
  if (l_var %in% names(data)) {
    # Shift more for high-risk individuals (L > 0)
    values <- data[[trt]]
    high_risk <- data[[l_var]] > 0
    
    # Larger shift for high-risk
    values[high_risk] <- pmin(values[high_risk] + 2, max_score)
    values[!high_risk] <- pmin(values[!high_risk] + 1, max_score)
    
    return(values)
  } else {
    return(data[[trt]])
  }
}
```

## Comparison with Natural Course

```{r comparison}
# Run simulation comparing interventions
comparison_results <- margot_simulate_causal(
  n = 1000,
  waves = 3,
  treatments = "a",
  interventions = list(
    natural = function(data, time, trt) data[[trt]],
    shift_up_1 = create_shift_intervention(1, 1, 7, start_wave = 1),
    shift_up_2 = create_shift_intervention(2, 1, 7, start_wave = 1),
    threshold_3 = create_threshold_shift(3, 3, "up", start_wave = 1)
  ),
  common_params = list(
    params = list(a_lag_y_coef = 0.3)
  ),
  seed = 999
)

# Extract and compare effects
effects <- comparison_results$effects$estimate
names(effects) <- comparison_results$effects$contrast

print(effects)
```

## Summary

The `margot.sim` package supports flexible shift interventions that:

1. **Match lmtp-style shifts**: Keep baseline natural, shift at specific waves
2. **Handle bounds**: Respect minimum/maximum values
3. **Support complex policies**: Wave-specific, threshold-based, covariate-dependent
4. **Work with any exposure type**: Binary or continuous

The key is that intervention functions receive:
- `data`: The current dataset
- `time`: The current wave (0, 1, 2, ...)
- `trt`: The treatment variable name

This allows complete flexibility in defining modified treatment policies.